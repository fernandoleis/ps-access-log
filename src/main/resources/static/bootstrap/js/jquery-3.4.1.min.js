/ *! jQuery Migrate v3.1.0 | (c) Fundação OpenJS e outros colaboradores | jquery.org/license * /
"undefined" == tipo de jQuery.migrateMute && (jQuery.migrateMute =! 0), função (t) {"função" = tipo de definição de && define.amd? define (["jquery"], função (e) {return t (e , janela)}): "objeto" == tipo de módulo && module.exports? module.exports = t (require ("jquery"), window): t (jQuery, window)} (function (s, n) {"use strict "; função e (e) {retornar 0 <= função (e, t) {para (var r = / ^ (\ d +) \. (\ d +) \. (\ d +) /, n = r.exec ( e) || [], o = r.exec (t) || [], i = 1; i <= 3; i ++) {if (+ n [i]> + o [i]) retorna 1; se (+ n [i] <+ o [i]) return-1} return 0} (s.fn.jquery, e)} s.migrateVersion = "3.1.0", n.console && n.console.log && (s && e ( "3.0.0") || n.console.log ("JQMIGRATE: jQuery 3.0.0+ NECESSÁRIO"), s.migrateWarnings && n.console.log ("JQMIGRATE: Migrar plug-in carregado várias vezes"), n.console.log ("JQMIGRATE: Migrate está instalado" + (s.migrateMute? "": "com o log ativo") + ", versão" + s.migrateVersion)); var r = {}; função u (e) { var t = n.console; r [e] || (r [e] =! 0, s.migrateWarnings.push (e), t && t.warn &&! s.migrateMute && (t.warn ("JQMIGRATE:" + e) , s.migrateTrace && t.trace && t.trace ()))} função t (e, t, r, n) {Object.defineProperty (e, t, {configurável:! 0, enumerável:! 0, get: function () { retornar u (n), r}, definir: função (e) {u (n), r = e}})} função o (e, t, r, n) {e [t] = função () {retornar u (n), r.apply (isto, argumentos)}} s.migrateWarnings = [], void 0 === s.migrateTrace && (s.migrateTrace =! 0), s.migrateReset = function () {r = { }, s.migrateWarnings.length = 0}, "BackCompat" === n.document.compatMode && u ("jQuery não é compatível com o modo Quirks"); var i, a = s.fn.init, c = s.isNumeric, d = s.find, l = / \ [(\ s * [- \ w] + \ s *) ([~ | ^ $ *]? =) \ s * ([- \ w #] *? # [- \ w #] *) \ s * \] /, p = / \ [(\ s * [- \ w] + \ s *) ([~ | ^ $ *]? =) \ s * ( [- \ w #] *? # [- \ w #] *) \ s * \] / g; for (i em s.fn.init = function (e) {var t = Array.prototype.slice.call (argumentos); retornar "string" == tipo de e && "#" === e && (u ("jQuery ('#') não é um seletor válido"), t [0] = []), a.apply ( isso, t)}, s.fn.init.prototype = s.fn, s.find = function (t) {var r = Array.prototype.slice.call (argumentos); if ("string" == typeof && l .test (t)) tente {n.document.querySelector (t)} catch (e) {t = t.replace (p, função (e, t, r, n) {return "[" + t + r + ' "'+ n +'"] '}); tente {n.document.querySelector (t), u ("O seletor de atributo com' # 'deve ser citado:" + r [0]), r [0] = t} catch (e) {u ("O seletor de atributo com '#' não foi corrigido:" + r [0])}} return d.apply (this,r)}, d) Object.prototype.hasOwnProperty.call (d, i) && (s.find [i] = d [i]); s.fn.size = function () {return u ("jQuery.fn .size () foi preterido e removido; use a propriedade .length "), this.length}, s.parseJSON = function () {return u (" jQuery.parseJSON foi preterido; use JSON.parse "), JSON.parse .apply (null, argumentos)}, s.isNumeric = função (e) {var t, r, n = c (e), o = (r = (t = e) && t.toString () ,! s.isArray (t) && 0 <= r-parseFloat (r) +1); return n! == o && u ("jQuery.isNumeric () não deve ser chamado em objetos construídos"), o}, e ("3.3.0") && o (s, "isWindow", função (e) {return null! = e && e === e.window}, "jQuery.isWindow () está obsoleto"), o (s, "holdReady", s.holdReady ", jQuery.holdReady está obsoleto "), o (s," exclusivo ", s.uniqueSort," jQuery.unique está obsoleto;use jQuery.uniqueSort "), t (s.expr," filtros ", s.expr.pseudos," jQuery.expr.filters está obsoleto; use jQuery.expr.pseudos "), t (s.expr,": " , s.expr.pseudos, "jQuery.expr [':'] está obsoleto; use jQuery.expr.pseudos"), e ("3.2.0") && o (s, "nodeName", s.nodeName, "jQuery .nodeName está obsoleto "); var f = s.ajax; s.ajax = function () {var e = f.apply (isto, argumentos); retorna e.promise && (o (e," success ", e.done , "jQXHR.success foi descontinuado e removido"), o (e, "erro", e.fail, "jQXHR.error foi descontinuado e removido"), o (e, "completo", e.sempre ", jQXHR. complete foi descontinuado e removido ")), e}; var y = s.fn.removeAttr, m = s.fn.toggleClass, h = / \ S + / g; s.fn.removeAttr = função (e) {var r = this; return s.each (e.match (h), função (e, t) {s.expr.match.bool.test (t) && (u ("jQuery.fn.removeAttr não define mais propriedades booleanas:" + t), r.prop (t,! 1))}), y.apply (isto, argumentos)}; var g =! (s.fn.toggleClass = function (t) {return void 0! == t && "boolean"! = tipo de t? m.apply (isto, argumentos) :( u ("jQuery.fn.toggleClass (booleano) está obsoleto "), this.each (function () {var e = this.getAttribute && this.getAttribute (" class ") ||" "; e && s.data (este," __ className __ ", e), this.setAttribute && this.setAttribute ( "classe", e ||! 1 === t? "": s.data (este, "__ className __") || "")}))}); s.swap && s.each (["height", " width "," reliableMarginRight "], função (e, t) {var r = s.cssHooks [t] && s.cssHooks [t] .get; r && (s.cssHooks [t] .get = function () {var e ; return g =! 0, e = r.apply (isto, argumentos), g =!1, e})}), s.swap = function (e, t, r, n) {var o, i, a = {}; para (i em g || u ("jQuery.swap () não é documentado e obsoleto "), t) a [i] = e.style [i], e.style [i] = t [i]; para (i in o = r.apply (e, n || []), t) e.style [i] = a [i]; retorno o}; var v = s.data; s.data = função (e, t, r) {var n; if (t && "objeto" == typeof t && 2 === argument.length) {n = s.hasDados (e) && v.call (this, e); var o = {}; para (var i in t) i! == s.camelCase (i)? (u ("jQuery.data () sempre define / obtém nomes camelCased:" + i), n [i] = t [i]): o [i] = t [i]; retorna v.call (this, e , o), t} retornar t && "string" == tipo de t && t! == s.camelCase (t) && (n = s.hasDados (e) && v.call (this, e)) && t in n? (u ( "jQuery.data () sempre define / obtém nomes camelCased:" + t), 2 <argumentos.length && (n [t] = r), n [t]): v.apply (this, argument)}; function j (e) {return e} var Q = s.Tween.prototype.run; s.Tween.prototype.run = function () {1 <s.easing [this.easing] .length && (u ("'jQuery.easing." + this.easing.toString () + "' deve usar apenas um argumento"), s .easing [this.easing] = j), Q.apply (this, argumentos)}; var w = s.fx.interval || 13, b = "jQuery.fx.interval está obsoleto"; n.requestAnimationFrame && Object.defineProperty (s.fx, "intervalo", {configurável:! 0, enumerável:! 0, get: function () {retorna n.document.hidden || u (b), w}, define: function (e) {u (b), w = e}}); var x = s.fn.load, k = s.event.add, A = s.event.fix; s.event.props = [], s.event.fix = {}, t (s.event.props, "concat", s.event.props.concat, "jQuery.event.props.concat () foi descontinuado e removido"), s.event.fix = function (e ) {var t, r = e.type, n = this.fixHooks [r], o = s.event.props; if (o.length) {u ("jQuery.event.props foram descontinuados e removidos:" o.join ()); while (o.length) s.event.addProp (o.pop ())} if (n &&! n._migrated _ && (n._migrated _ =! 0, u ("jQuery.event.fixHooks foram descontinuados e removidos:" + r), (o = n.props) && o.length)) while (o.length) s.event.addProp (o.pop ()); return t = A.call (this, e), n && n.filter? n.filter (t , e): t}, s.event.add = function (e, t) {return e === n && "load" === t && "complete" === n.document.readyState && u ("jQuery (janela) .on ('load' ...) chamado após o evento load ter ocorrido "), k.apply (this, argumentos)}, s.each ([" load "," unload "," error "], função (e, t) {s.fn [t] = function () {var e = Array.prototype.slice.call (argumentos, 0); retorna "load" === t && "string" == tipo de e [0]? x .apply (this, e) :( u ("jQuery.fn." + t + "() está obsoleto"), e.splice (0,0, t), argument.length? this.on.apply (this, e) :( this.triggerHandler.apply (this, e), this))}}), s.each ("desfoque o foco, o foco no foco, redimensionar a rolagem, clique em dblclick mousedown mouseup, mousemown mouseup keypress keyup contextmenu ".split (" "), function (e, r) {s.fn [r] = function (e, t) {return u (" jQuery.fn. "+ r +" () evento abreviado "), 0 <argument.length? This.on (r, null, e, t): this.trigger (r)}}), s (function () {s (n.document) .triggerHandler (" ready " )}), s.event.special.ready = {setup: function () {this === n.document && u ("o evento 'ready' foi descontinuado")}}, s.fn.extend ({bind: function ( e, t, r) {return u ("jQuery.fn.bind () está obsoleto"), this.on (e, null, t, r)}, unbind: function (e, t) {return u (" jQuery.fn.unbind () está obsoleto "), this.off (e, null, t)}, delega:function (e, t, r, n) {return u ("jQuery.fn.delegate () está obsoleto"), this.on (t, e, r, n)}, undelegate: function (e, t, r ) {return u ("jQuery.fn.undelegate () está obsoleto"), 1 === argumentos.length? this.off (e, "**"): this.off (t, e || "** ", r)}, hover: function (e, t) {return u (" jQuery.fn.hover () está obsoleto "), this.on (" mouseenter ", e) .on (" mouseleave ", t | | e)}}); var S = s.fn.offset; s.fn.offset = function () {var e, t = this [0], r = {top: 0, left: 0}; return t && t .nodeType? (e = (t.ownerDocument || n.document) .documentElement, s.contains (e, t)? S.apply (isto, argumentos) :( u ("jQuery.fn.offset () requer um elemento conectado a um documento "), r)) :( u (" jQuery.fn.offset () requer um elemento DOM válido "), r)}; var q = s.param; s.param = function (e, t) {var r = s.ajaxSettings && s.ajaxSettings.traditional;return void 0 === t && r && (u ("jQuery.param () não usa mais jQuery.ajaxSettings.traditional"), t = r), q.call (this, e, t)}; var C = s.fn .andSelf || s.fn.addBack; s.fn.andSelf = function () {return u ("jQuery.fn.andSelf () foi reprovado e removido, use jQuery.fn.addBack ()"), C.apply (isto, argumentos)}; var M = s.Deferido, R = [["resolver", "pronto", s.Callbacks ("uma vez memória"), s.Callbacks ("uma vez memória"), "resolvido"] , ["rejeitar", "falhar", s.Callbacks ("uma vez memória"), s.Callbacks ("uma vez memória"), "rejeitado"], ["notificar", "progresso", s.Callbacks ("memória "), s.Callbacks (" memory ")]]; return s.Deferred = function (e) {vari = M (), a = i.promise (); return i.pipe = a.pipe = function ( ) {var o = argumentos; retorno u ("deferred.pipe () está obsoleto")), s.Deferido (função (n) {s.cada (R, função (e, t) {var r = s.is Função (o [e]) && o [e]; i [t [1]] (função () {var e = r && r.apply (this, argumentos); e && s.isFunction (e.promise)? e.promise (). done (n.resolve) .fail (n.reject) .progress (n.notify) : n [t [0] + "With"] (this === a? n.promise (): this, r? [e]: argumentos)})}), o = null}). , e && e.call (i, i), i}, s.Deferred.exceptionHook = M.exceptionHook, s});